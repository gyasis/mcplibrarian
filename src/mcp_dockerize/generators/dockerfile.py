"""Dockerfile generator for MCP servers."""

import os
from pathlib import Path
from jinja2 import Environment, FileSystemLoader
from typing import Dict

from ..detectors.python import ServerMetadata


class DockerfileGenerator:
    """Generate optimized Dockerfiles for MCP servers."""

    def __init__(self):
        # Setup Jinja2 environment
        template_dir = Path(__file__).parent.parent / "templates"
        self.env = Environment(loader=FileSystemLoader(str(template_dir)))

    def generate(self, metadata: ServerMetadata, output_dir: Path, server_path: Path) -> Path:
        """Generate Dockerfile and supporting files.

        Args:
            metadata: Server metadata from detector
            output_dir: Directory to write files to
            server_path: Path to the original server source code

        Returns:
            Path to generated Dockerfile
        """
        output_dir.mkdir(parents=True, exist_ok=True)

        # Decide deployment pattern based on volume requirements
        deployment_pattern = self._choose_deployment_pattern(metadata)

        # Generate Dockerfile
        dockerfile_path = self._generate_dockerfile(metadata, output_dir, deployment_pattern)

        # Generate docker-compose.yml
        self._generate_compose(metadata, output_dir, deployment_pattern, server_path)

        # Generate .env.example
        if metadata.env_vars:
            self._generate_env_example(metadata, output_dir)

        # Generate README with instructions
        self._generate_readme(metadata, output_dir, deployment_pattern)

        return dockerfile_path

    def _choose_deployment_pattern(self, metadata: ServerMetadata) -> str:
        """Choose between 'volume-mounted' or 'self-contained' deployment.

        Logic:
        - If server has large volume mounts (>100MB) → volume-mounted
        - If server has absolute path dependencies → volume-mounted
        - If server is pure Python with uv entry → self-contained
        - Default: self-contained (safer, more portable)
        """
        # Check for large volume mounts (indicator: /data, /media paths)
        for volume_source in metadata.volume_mounts.keys():
            if any(indicator in volume_source for indicator in ["/media/", "/mnt/", "Drive"]):
                return "volume-mounted"

        # Check for database/storage volumes
        for volume_dest in metadata.volume_mounts.values():
            if "/data" in volume_dest:
                return "volume-mounted"

        # UV-based servers are good candidates for self-contained
        if metadata.server_type == "python-uv":
            return "self-contained"

        # Default: volume-mounted (preserves existing project structure)
        return "volume-mounted"

    def _generate_dockerfile(self, metadata: ServerMetadata, output_dir: Path, pattern: str) -> Path:
        """Generate Dockerfile from template."""
        # Choose template based on pattern
        if pattern == "self-contained":
            template = self.env.get_template("python-uv.Dockerfile.j2")
        else:
            template = self.env.get_template("python-direct.Dockerfile.j2")

        # Render template
        dockerfile_content = template.render(
            python_version=metadata.python_version,
            entry_point=metadata.entry_point,
            dependencies=metadata.dependencies,
            server_type=metadata.server_type
        )

        # Write Dockerfile
        dockerfile_path = output_dir / "Dockerfile"
        dockerfile_path.write_text(dockerfile_content)

        return dockerfile_path

    def _generate_compose(self, metadata: ServerMetadata, output_dir: Path, pattern: str, server_path: Path):
        """Generate docker-compose.yml for easy container management."""
        compose_content = f"""# Docker Compose configuration for {metadata.name}
# Generated by mcplibrarian

version: '3.8'

services:
  {metadata.name}:
    build:
      context: .
      dockerfile: Dockerfile
    container_name: mcp-{metadata.name}
    stdin_open: true  # Required for MCP stdio
    tty: false
"""

        # Add volumes based on deployment pattern
        if pattern == "volume-mounted":
            compose_content += "    volumes:\n"

            # Mount source code - use type: bind syntax for absolute paths
            source_path_abs = str(server_path.resolve())
            compose_content += f"      - type: bind\n"
            compose_content += f"        source: {source_path_abs}\n"
            compose_content += f"        target: /app\n"
            compose_content += f"        read_only: true\n"

            # Mount additional volumes
            for source, dest in metadata.volume_mounts.items():
                compose_content += f"      - type: bind\n"
                compose_content += f"        source: {source}\n"
                # For data volumes, preserve the original path structure if it looks like an absolute host path
                # This handles cases where code has hardcoded paths
                if source.startswith("/media/") or source.startswith("/mnt/"):
                    compose_content += f"        target: {source}\n"  # Mount at same path as host
                else:
                    compose_content += f"        target: {dest}\n"
                compose_content += f"        read_only: true\n"

        # Add environment file if exists
        if metadata.env_file:
            compose_content += f"""    env_file:
      - {metadata.env_file}
"""

        # Add security warnings
        if metadata.warnings:
            compose_content += "\n# ⚠️  SECURITY WARNINGS:\n"
            for warning in metadata.warnings:
                compose_content += f"#    - {warning}\n"

        compose_path = output_dir / "docker-compose.yml"
        compose_path.write_text(compose_content)

    def _generate_env_example(self, metadata: ServerMetadata, output_dir: Path):
        """Generate .env.example file showing required environment variables."""
        env_example = "# Environment variables for MCP server\n"
        env_example += "# Copy this to .env and fill in your values\n\n"

        for key in metadata.env_vars.keys():
            # Mask sensitive values
            if any(secret in key.lower() for secret in ["key", "secret", "password", "token"]):
                env_example += f"{key}=<YOUR_{key}_HERE>\n"
            else:
                env_example += f"{key}=\n"

        env_path = output_dir / ".env.example"
        env_path.write_text(env_example)

    def _generate_readme(self, metadata: ServerMetadata, output_dir: Path, pattern: str):
        """Generate README with usage instructions."""
        readme = f"""# Docker Configuration for {metadata.name}

Auto-generated by `mcplibrarian`

## Server Information

- **Type**: {metadata.server_type}
- **Python Version**: {metadata.python_version}
- **Entry Point**: {metadata.entry_point}
- **Deployment Pattern**: {pattern}

## Quick Start

### Build Image

```bash
docker compose build
```

### Run Container

```bash
docker compose up -d
```

### Test MCP Connection

```bash
echo '{{"jsonrpc":"2.0","method":"initialize","params":{{}}}}' | docker compose run --rm {metadata.name}
```

## Deployment Pattern: {pattern.title()}

"""

        if pattern == "volume-mounted":
            readme += """This server uses **volume-mounted** deployment:
- Source code is mounted from the host (read-only)
- Large data files are mounted from existing locations
- Container does not copy code, only dependencies

**Advantages:**
- No code duplication
- Easy to update (just rebuild container)
- Access to large host files without copying

**Volume Mounts:**
"""
            for source, dest in metadata.volume_mounts.items():
                readme += f"- `{source}` → `{dest}`\n"

        else:
            readme += """This server uses **self-contained** deployment:
- Code is copied into the container
- All dependencies installed with uv
- Portable and reproducible

**Advantages:**
- Fully isolated from host
- Can run anywhere
- Reproducible builds

"""

        # Add environment variables section
        if metadata.env_vars:
            readme += f"""
## Environment Variables

Copy `.env.example` to `.env` and configure:

"""
            for key in metadata.env_vars.keys():
                readme += f"- `{key}`\n"

        # Add security warnings
        if metadata.warnings:
            readme += """
## ⚠️  Security Warnings

"""
            for warning in metadata.warnings:
                readme += f"- {warning}\n"

        # Add Claude Code integration section
        readme += f"""
## Claude Code Integration

Add to `~/.config/Claude/claude_desktop_config.json`:

```json
{{
  "mcpServers": {{
    "{metadata.name}": {{
      "command": "docker",
      "args": ["compose", "-f", "{output_dir}/docker-compose.yml", "run", "--rm", "{metadata.name}"]
    }}
  }}
}}
```

## Cleanup

```bash
docker compose down
docker image rm mcp-{metadata.name}
```

---

*Generated by mcplibrarian | Non-destructive, read-only analysis*
"""

        readme_path = output_dir / "README.md"
        readme_path.write_text(readme)
